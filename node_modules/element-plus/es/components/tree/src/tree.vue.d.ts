import type Node from './model/node';
import type { ComponentInternalInstance } from 'vue';
import type { Nullable } from 'element-plus/es/utils';
import type { FilterValue, TreeData, TreeKey, TreeNodeData } from './tree.type';
declare const __VLS_export: import("vue").DefineComponent<{
    readonly data: import("element-plus/es/utils").EpPropFinalized<(new (...args: any[]) => TreeData) | (() => TreeData) | ((new (...args: any[]) => TreeData) | (() => TreeData))[], unknown, unknown, () => never[], boolean>;
    readonly emptyText: {
        readonly type: import("vue").PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly renderAfterExpand: import("element-plus/es/utils").EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly nodeKey: StringConstructor;
    readonly checkStrictly: BooleanConstructor;
    readonly defaultExpandAll: BooleanConstructor;
    readonly expandOnClickNode: import("element-plus/es/utils").EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly checkOnClickNode: BooleanConstructor;
    readonly checkOnClickLeaf: import("element-plus/es/utils").EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly checkDescendants: BooleanConstructor;
    readonly autoExpandParent: import("element-plus/es/utils").EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly defaultCheckedKeys: {
        readonly type: import("vue").PropType<TreeKey[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly defaultExpandedKeys: {
        readonly type: import("vue").PropType<TreeKey[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly currentNodeKey: {
        readonly type: import("vue").PropType<import("element-plus/es/utils").EpPropMergeType<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly renderContent: {
        readonly type: import("vue").PropType<import("./tree.type").RenderContentFunction>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly showCheckbox: BooleanConstructor;
    readonly draggable: BooleanConstructor;
    readonly allowDrag: {
        readonly type: import("vue").PropType<import("./tree.type").AllowDragFunction>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly allowDrop: {
        readonly type: import("vue").PropType<import("./tree.type").AllowDropFunction>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly props: import("element-plus/es/utils").EpPropFinalized<(new (...args: any[]) => import("./tree.type").TreeOptionProps) | (() => import("./tree.type").TreeOptionProps) | ((new (...args: any[]) => import("./tree.type").TreeOptionProps) | (() => import("./tree.type").TreeOptionProps))[], unknown, unknown, () => {
        children: string;
        label: string;
        disabled: string;
    }, boolean>;
    readonly lazy: BooleanConstructor;
    readonly highlightCurrent: BooleanConstructor;
    readonly load: {
        readonly type: import("vue").PropType<import("./tree.type").LoadFunction>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly filterNodeMethod: {
        readonly type: import("vue").PropType<import("./tree.type").FilterNodeMethodFunction>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly accordion: BooleanConstructor;
    readonly indent: import("element-plus/es/utils").EpPropFinalized<NumberConstructor, unknown, unknown, 18, boolean>;
    readonly icon: {
        readonly type: import("vue").PropType<import("element-plus/es/utils").EpPropMergeType<(new (...args: any[]) => (string | import("vue").Component) & {}) | (() => string | import("vue").Component) | ((new (...args: any[]) => (string | import("vue").Component) & {}) | (() => string | import("vue").Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}, {
    ns: {
        namespace: import("vue").ComputedRef<string>;
        b: (blockSuffix?: string) => string;
        e: (element?: string) => string;
        m: (modifier?: string) => string;
        be: (blockSuffix?: string, element?: string) => string;
        em: (element?: string, modifier?: string) => string;
        bm: (blockSuffix?: string, modifier?: string) => string;
        bem: (blockSuffix?: string, element?: string, modifier?: string) => string;
        is: {
            (name: string, state: boolean | undefined): string;
            (name: string): string;
        };
        cssVar: (object: Record<string, string>) => Record<string, string>;
        cssVarName: (name: string) => string;
        cssVarBlock: (object: Record<string, string>) => Record<string, string>;
        cssVarBlockName: (name: string) => string;
    };
    store: import("vue").Ref<{
        currentNode: {
            id: number;
            text: string | null;
            checked: boolean;
            indeterminate: boolean;
            data: TreeNodeData;
            expanded: boolean;
            parent: any | null;
            visible: boolean;
            isCurrent: boolean;
            store: any;
            isLeafByUser: boolean | undefined;
            isLeaf: boolean | undefined;
            canFocus: boolean;
            level: number;
            loaded: boolean;
            childNodes: any[];
            loading: boolean;
            isEffectivelyChecked: boolean;
            initialize: () => void;
            setData: (data: TreeNodeData) => void;
            readonly label: string;
            readonly key: TreeKey | null | undefined;
            readonly disabled: boolean;
            readonly nextSibling: any | null;
            readonly previousSibling: any | null;
            contains: (target: Node, deep?: boolean) => boolean;
            remove: () => void;
            insertChild: (child?: import("./tree.type").FakeNode | Node, index?: number, batch?: boolean) => void;
            insertBefore: (child: import("./tree.type").FakeNode | Node, ref: Node) => void;
            insertAfter: (child: import("./tree.type").FakeNode | Node, ref: Node) => void;
            removeChild: (child: Node) => void;
            removeChildByData: (data: TreeNodeData | null) => void;
            expand: (callback?: (() => void) | null, expandParent?: boolean) => void;
            doCreateChildren: (array: TreeNodeData[], defaultProps?: import("./tree.type").TreeNodeLoadedDefaultProps) => void;
            collapse: () => void;
            shouldLoadData: () => boolean;
            updateLeafState: () => void;
            setChecked: (value?: boolean | string, deep?: boolean, recursion?: boolean, passValue?: boolean) => void;
            getChildren: (forceInit?: boolean) => TreeNodeData | TreeNodeData[] | null;
            updateChildren: () => void;
            loadData: (callback: (data?: TreeNodeData[]) => void, defaultProps?: import("./tree.type").TreeNodeLoadedDefaultProps) => void;
            eachNode: (callback: (node: Node) => void) => void;
            reInitChecked: () => void;
        } | null;
        currentNodeKey: TreeKey | null;
        nodesMap: import("./tree.type").TreeStoreNodesMap;
        root: {
            id: number;
            text: string | null;
            checked: boolean;
            indeterminate: boolean;
            data: TreeNodeData;
            expanded: boolean;
            parent: any | null;
            visible: boolean;
            isCurrent: boolean;
            store: any;
            isLeafByUser: boolean | undefined;
            isLeaf: boolean | undefined;
            canFocus: boolean;
            level: number;
            loaded: boolean;
            childNodes: any[];
            loading: boolean;
            isEffectivelyChecked: boolean;
            initialize: () => void;
            setData: (data: TreeNodeData) => void;
            readonly label: string;
            readonly key: TreeKey | null | undefined;
            readonly disabled: boolean;
            readonly nextSibling: any | null;
            readonly previousSibling: any | null;
            contains: (target: Node, deep?: boolean) => boolean;
            remove: () => void;
            insertChild: (child?: import("./tree.type").FakeNode | Node, index?: number, batch?: boolean) => void;
            insertBefore: (child: import("./tree.type").FakeNode | Node, ref: Node) => void;
            insertAfter: (child: import("./tree.type").FakeNode | Node, ref: Node) => void;
            removeChild: (child: Node) => void;
            removeChildByData: (data: TreeNodeData | null) => void;
            expand: (callback?: (() => void) | null, expandParent?: boolean) => void;
            doCreateChildren: (array: TreeNodeData[], defaultProps?: import("./tree.type").TreeNodeLoadedDefaultProps) => void;
            collapse: () => void;
            shouldLoadData: () => boolean;
            updateLeafState: () => void;
            setChecked: (value?: boolean | string, deep?: boolean, recursion?: boolean, passValue?: boolean) => void;
            getChildren: (forceInit?: boolean) => TreeNodeData | TreeNodeData[] | null;
            updateChildren: () => void;
            loadData: (callback: (data?: TreeNodeData[]) => void, defaultProps?: import("./tree.type").TreeNodeLoadedDefaultProps) => void;
            eachNode: (callback: (node: Node) => void) => void;
            reInitChecked: () => void;
        };
        data: TreeNodeData[];
        lazy: boolean;
        load?: import("./tree.type").LoadFunction | undefined;
        filterNodeMethod?: import("./tree.type").FilterNodeMethodFunction | undefined;
        key: TreeKey;
        defaultCheckedKeys?: TreeKey[] | undefined;
        checkStrictly: boolean;
        defaultExpandedKeys?: TreeKey[] | undefined;
        autoExpandParent: boolean;
        defaultExpandAll: boolean;
        checkDescendants: boolean;
        props: {
            children?: string | undefined;
            label?: (string | ((data: TreeNodeData, node: Node) => string)) | undefined;
            disabled?: (string | ((data: TreeNodeData, node: Node) => boolean)) | undefined;
            isLeaf?: (string | ((data: TreeNodeData, node: Node) => boolean)) | undefined;
            class?: ((data: TreeNodeData, node: Node) => string | {
                [key: string]: boolean;
            }) | undefined;
        };
        initialize: () => void;
        filter: (value: FilterValue) => void;
        setData: (newVal: TreeData) => void;
        getNode: (data: TreeKey | TreeNodeData | Node) => Node;
        insertBefore: (data: TreeNodeData, refData: TreeKey | TreeNodeData | Node) => void;
        insertAfter: (data: TreeNodeData, refData: TreeKey | TreeNodeData | Node) => void;
        remove: (data: TreeNodeData | Node) => void;
        append: (data: TreeNodeData, parentData: TreeNodeData | TreeKey | Node) => void;
        _initDefaultCheckedNodes: () => void;
        _initDefaultCheckedNode: (node: Node) => void;
        setDefaultCheckedKey: (newVal: TreeKey[]) => void;
        registerNode: (node: Node) => void;
        deregisterNode: (node: Node) => void;
        getCheckedNodes: (leafOnly?: boolean, includeHalfChecked?: boolean) => TreeNodeData[];
        getCheckedKeys: (leafOnly?: boolean) => TreeKey[];
        getHalfCheckedNodes: () => TreeNodeData[];
        getHalfCheckedKeys: () => TreeKey[];
        _getAllNodes: () => Node[];
        updateChildren: (key: TreeKey, data: TreeData) => void;
        _setCheckedKeys: (key: TreeKey, leafOnly: boolean | undefined, checkedKeys: {
            [key: string]: boolean;
        }) => void;
        setCheckedNodes: (array: Node[], leafOnly?: boolean) => void;
        setCheckedKeys: (keys: TreeKey[], leafOnly?: boolean) => void;
        setDefaultExpandedKeys: (keys: TreeKey[]) => void;
        setChecked: (data: TreeKey | TreeNodeData, checked: boolean, deep: boolean) => void;
        getCurrentNode: () => Node | null;
        setCurrentNode: (currentNode: Node) => void;
        setUserCurrentNode: (node: Node, shouldAutoExpandParent?: boolean) => void;
        setCurrentNodeKey: (key: TreeKey | null, shouldAutoExpandParent?: boolean) => void;
    }>;
    root: import("vue").Ref<{
        id: number;
        text: string | null;
        checked: boolean;
        indeterminate: boolean;
        data: TreeNodeData;
        expanded: boolean;
        parent: any | null;
        visible: boolean;
        isCurrent: boolean;
        store: any;
        isLeafByUser: boolean | undefined;
        isLeaf: boolean | undefined;
        canFocus: boolean;
        level: number;
        loaded: boolean;
        childNodes: any[];
        loading: boolean;
        isEffectivelyChecked: boolean;
        initialize: () => void;
        setData: (data: TreeNodeData) => void;
        readonly label: string;
        readonly key: TreeKey | null | undefined;
        readonly disabled: boolean;
        readonly nextSibling: any | null;
        readonly previousSibling: any | null;
        contains: (target: Node, deep?: boolean) => boolean;
        remove: () => void;
        insertChild: (child?: import("./tree.type").FakeNode | Node, index?: number, batch?: boolean) => void;
        insertBefore: (child: import("./tree.type").FakeNode | Node, ref: Node) => void;
        insertAfter: (child: import("./tree.type").FakeNode | Node, ref: Node) => void;
        removeChild: (child: Node) => void;
        removeChildByData: (data: TreeNodeData | null) => void;
        expand: (callback?: (() => void) | null, expandParent?: boolean) => void;
        doCreateChildren: (array: TreeNodeData[], defaultProps?: import("./tree.type").TreeNodeLoadedDefaultProps) => void;
        collapse: () => void;
        shouldLoadData: () => boolean;
        updateLeafState: () => void;
        setChecked: (value?: boolean | string, deep?: boolean, recursion?: boolean, passValue?: boolean) => void;
        getChildren: (forceInit?: boolean) => TreeNodeData | TreeNodeData[] | null;
        updateChildren: () => void;
        loadData: (callback: (data?: TreeNodeData[]) => void, defaultProps?: import("./tree.type").TreeNodeLoadedDefaultProps) => void;
        eachNode: (callback: (node: Node) => void) => void;
        reInitChecked: () => void;
    }>;
    currentNode: import("vue").Ref<{
        id: number;
        text: string | null;
        checked: boolean;
        indeterminate: boolean;
        data: TreeNodeData;
        expanded: boolean;
        parent: any | null;
        visible: boolean;
        isCurrent: boolean;
        store: any;
        isLeafByUser: boolean | undefined;
        isLeaf: boolean | undefined;
        canFocus: boolean;
        level: number;
        loaded: boolean;
        childNodes: any[];
        loading: boolean;
        isEffectivelyChecked: boolean;
        initialize: () => void;
        setData: (data: TreeNodeData) => void;
        readonly label: string;
        readonly key: TreeKey | null | undefined;
        readonly disabled: boolean;
        readonly nextSibling: any | null;
        readonly previousSibling: any | null;
        contains: (target: Node, deep?: boolean) => boolean;
        remove: () => void;
        insertChild: (child?: import("./tree.type").FakeNode | Node, index?: number, batch?: boolean) => void;
        insertBefore: (child: import("./tree.type").FakeNode | Node, ref: Node) => void;
        insertAfter: (child: import("./tree.type").FakeNode | Node, ref: Node) => void;
        removeChild: (child: Node) => void;
        removeChildByData: (data: TreeNodeData | null) => void;
        expand: (callback?: (() => void) | null, expandParent?: boolean) => void;
        doCreateChildren: (array: TreeNodeData[], defaultProps?: import("./tree.type").TreeNodeLoadedDefaultProps) => void;
        collapse: () => void;
        shouldLoadData: () => boolean;
        updateLeafState: () => void;
        setChecked: (value?: boolean | string, deep?: boolean, recursion?: boolean, passValue?: boolean) => void;
        getChildren: (forceInit?: boolean) => TreeNodeData | TreeNodeData[] | null;
        updateChildren: () => void;
        loadData: (callback: (data?: TreeNodeData[]) => void, defaultProps?: import("./tree.type").TreeNodeLoadedDefaultProps) => void;
        eachNode: (callback: (node: Node) => void) => void;
        reInitChecked: () => void;
    } | null>;
    dragState: import("vue").Ref<{
        allowDrop: boolean;
        dropType: import("./tree.type").NodeDropType | null;
        draggingNode: {
            node: {
                id: number;
                text: string | null;
                checked: boolean;
                indeterminate: boolean;
                data: TreeNodeData;
                expanded: boolean;
                parent: any | null;
                visible: boolean;
                isCurrent: boolean;
                store: any;
                isLeafByUser: boolean | undefined;
                isLeaf: boolean | undefined;
                canFocus: boolean;
                level: number;
                loaded: boolean;
                childNodes: any[];
                loading: boolean;
                isEffectivelyChecked: boolean;
                initialize: () => void;
                setData: (data: TreeNodeData) => void;
                readonly label: string;
                readonly key: TreeKey | null | undefined;
                readonly disabled: boolean;
                readonly nextSibling: any | null;
                readonly previousSibling: any | null;
                contains: (target: Node, deep?: boolean) => boolean;
                remove: () => void;
                insertChild: (child?: import("./tree.type").FakeNode | Node, index?: number, batch?: boolean) => void;
                insertBefore: (child: import("./tree.type").FakeNode | Node, ref: Node) => void;
                insertAfter: (child: import("./tree.type").FakeNode | Node, ref: Node) => void;
                removeChild: (child: Node) => void;
                removeChildByData: (data: TreeNodeData | null) => void;
                expand: (callback?: (() => void) | null, expandParent?: boolean) => void;
                doCreateChildren: (array: TreeNodeData[], defaultProps?: import("./tree.type").TreeNodeLoadedDefaultProps) => void;
                collapse: () => void;
                shouldLoadData: () => boolean;
                updateLeafState: () => void;
                setChecked: (value?: boolean | string, deep?: boolean, recursion?: boolean, passValue?: boolean) => void;
                getChildren: (forceInit?: boolean) => TreeNodeData | TreeNodeData[] | null;
                updateChildren: () => void;
                loadData: (callback: (data?: TreeNodeData[]) => void, defaultProps?: import("./tree.type").TreeNodeLoadedDefaultProps) => void;
                eachNode: (callback: (node: Node) => void) => void;
                reInitChecked: () => void;
            };
            $el?: HTMLElement | undefined;
        } | null;
        showDropIndicator: boolean;
        dropNode: {
            node: {
                id: number;
                text: string | null;
                checked: boolean;
                indeterminate: boolean;
                data: TreeNodeData;
                expanded: boolean;
                parent: any | null;
                visible: boolean;
                isCurrent: boolean;
                store: any;
                isLeafByUser: boolean | undefined;
                isLeaf: boolean | undefined;
                canFocus: boolean;
                level: number;
                loaded: boolean;
                childNodes: any[];
                loading: boolean;
                isEffectivelyChecked: boolean;
                initialize: () => void;
                setData: (data: TreeNodeData) => void;
                readonly label: string;
                readonly key: TreeKey | null | undefined;
                readonly disabled: boolean;
                readonly nextSibling: any | null;
                readonly previousSibling: any | null;
                contains: (target: Node, deep?: boolean) => boolean;
                remove: () => void;
                insertChild: (child?: import("./tree.type").FakeNode | Node, index?: number, batch?: boolean) => void;
                insertBefore: (child: import("./tree.type").FakeNode | Node, ref: Node) => void;
                insertAfter: (child: import("./tree.type").FakeNode | Node, ref: Node) => void;
                removeChild: (child: Node) => void;
                removeChildByData: (data: TreeNodeData | null) => void;
                expand: (callback?: (() => void) | null, expandParent?: boolean) => void;
                doCreateChildren: (array: TreeNodeData[], defaultProps?: import("./tree.type").TreeNodeLoadedDefaultProps) => void;
                collapse: () => void;
                shouldLoadData: () => boolean;
                updateLeafState: () => void;
                setChecked: (value?: boolean | string, deep?: boolean, recursion?: boolean, passValue?: boolean) => void;
                getChildren: (forceInit?: boolean) => TreeNodeData | TreeNodeData[] | null;
                updateChildren: () => void;
                loadData: (callback: (data?: TreeNodeData[]) => void, defaultProps?: import("./tree.type").TreeNodeLoadedDefaultProps) => void;
                eachNode: (callback: (node: Node) => void) => void;
                reInitChecked: () => void;
            };
            $el?: HTMLElement | undefined;
        } | null;
    }>;
    el$: import("vue").Ref<Nullable<HTMLElement>>;
    dropIndicator$: import("vue").Ref<Nullable<HTMLElement>>;
    isEmpty: import("vue").ComputedRef<boolean>;
    filter: (value: FilterValue) => void;
    getNodeKey: (node: Node) => any;
    getNodePath: (data: TreeKey | TreeNodeData) => TreeNodeData[];
    getCheckedNodes: (leafOnly?: boolean, includeHalfChecked?: boolean) => TreeNodeData[];
    getCheckedKeys: (leafOnly?: boolean) => TreeKey[];
    getCurrentNode: () => TreeNodeData | null;
    getCurrentKey: () => TreeKey | null;
    setCheckedNodes: (nodes: Node[], leafOnly?: boolean) => void;
    setCheckedKeys: (keys: TreeKey[], leafOnly?: boolean) => void;
    setChecked: (data: TreeKey | TreeNodeData, checked: boolean, deep: boolean) => void;
    getHalfCheckedNodes: () => TreeNodeData[];
    getHalfCheckedKeys: () => TreeKey[];
    setCurrentNode: (node: Node, shouldAutoExpandParent?: boolean) => void;
    setCurrentKey: (key?: TreeKey | null, shouldAutoExpandParent?: boolean) => void;
    t: import("element-plus/es/hooks").Translator;
    getNode: (data: TreeKey | TreeNodeData) => Node;
    remove: (data: TreeNodeData | Node) => void;
    append: (data: TreeNodeData, parentNode: TreeNodeData | TreeKey | Node) => void;
    insertBefore: (data: TreeNodeData, refNode: TreeKey | TreeNodeData | Node) => void;
    insertAfter: (data: TreeNodeData, refNode: TreeKey | TreeNodeData | Node) => void;
    handleNodeExpand: (nodeData: TreeNodeData, node: Node, instance: ComponentInternalInstance) => void;
    updateKeyChildren: (key: TreeKey, data: TreeData) => void;
}, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {
    'check-change': (data: any, checked: boolean, indeterminate: boolean) => any;
    'current-change': (data: any | null, node: Node | null) => boolean;
    'node-click': (data: any, node: Node, nodeInstance: ComponentInternalInstance | null, evt: MouseEvent) => any;
    'node-contextmenu': (evt: Event, data: any, node: Node, nodeInstance: ComponentInternalInstance | null) => any;
    'node-collapse': (data: any, node: Node, nodeInstance: ComponentInternalInstance | null) => any;
    'node-expand': (data: any, node: Node, nodeInstance: ComponentInternalInstance | null) => any;
    check: (data: any, checkedInfo: import("./tree.type").CheckedInfo) => any;
    'node-drag-start': (node: Node, evt: DragEvent) => DragEvent;
    'node-drag-end': (draggingNode: Node, dropNode: Node | null, dropType: import("./tree.type").NodeDropType, evt: DragEvent) => DragEvent;
    'node-drop': (draggingNode: Node, dropNode: Node, dropType: Exclude<import("./tree.type").NodeDropType, "none">, evt: DragEvent) => DragEvent;
    'node-drag-leave': (draggingNode: Node, oldDropNode: Node, evt: DragEvent) => DragEvent;
    'node-drag-enter': (draggingNode: Node, dropNode: Node, evt: DragEvent) => DragEvent;
    'node-drag-over': (draggingNode: Node, dropNode: Node, evt: DragEvent) => DragEvent;
}, string, import("vue").PublicProps, Readonly<import("vue").ExtractPropTypes<{
    readonly data: import("element-plus/es/utils").EpPropFinalized<(new (...args: any[]) => TreeData) | (() => TreeData) | ((new (...args: any[]) => TreeData) | (() => TreeData))[], unknown, unknown, () => never[], boolean>;
    readonly emptyText: {
        readonly type: import("vue").PropType<string>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly renderAfterExpand: import("element-plus/es/utils").EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly nodeKey: StringConstructor;
    readonly checkStrictly: BooleanConstructor;
    readonly defaultExpandAll: BooleanConstructor;
    readonly expandOnClickNode: import("element-plus/es/utils").EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly checkOnClickNode: BooleanConstructor;
    readonly checkOnClickLeaf: import("element-plus/es/utils").EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly checkDescendants: BooleanConstructor;
    readonly autoExpandParent: import("element-plus/es/utils").EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    readonly defaultCheckedKeys: {
        readonly type: import("vue").PropType<TreeKey[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly defaultExpandedKeys: {
        readonly type: import("vue").PropType<TreeKey[]>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly currentNodeKey: {
        readonly type: import("vue").PropType<import("element-plus/es/utils").EpPropMergeType<(new (...args: any[]) => string | number) | (() => string | number) | ((new (...args: any[]) => string | number) | (() => string | number))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly renderContent: {
        readonly type: import("vue").PropType<import("./tree.type").RenderContentFunction>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly showCheckbox: BooleanConstructor;
    readonly draggable: BooleanConstructor;
    readonly allowDrag: {
        readonly type: import("vue").PropType<import("./tree.type").AllowDragFunction>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly allowDrop: {
        readonly type: import("vue").PropType<import("./tree.type").AllowDropFunction>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly props: import("element-plus/es/utils").EpPropFinalized<(new (...args: any[]) => import("./tree.type").TreeOptionProps) | (() => import("./tree.type").TreeOptionProps) | ((new (...args: any[]) => import("./tree.type").TreeOptionProps) | (() => import("./tree.type").TreeOptionProps))[], unknown, unknown, () => {
        children: string;
        label: string;
        disabled: string;
    }, boolean>;
    readonly lazy: BooleanConstructor;
    readonly highlightCurrent: BooleanConstructor;
    readonly load: {
        readonly type: import("vue").PropType<import("./tree.type").LoadFunction>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly filterNodeMethod: {
        readonly type: import("vue").PropType<import("./tree.type").FilterNodeMethodFunction>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
    readonly accordion: BooleanConstructor;
    readonly indent: import("element-plus/es/utils").EpPropFinalized<NumberConstructor, unknown, unknown, 18, boolean>;
    readonly icon: {
        readonly type: import("vue").PropType<import("element-plus/es/utils").EpPropMergeType<(new (...args: any[]) => (string | import("vue").Component) & {}) | (() => string | import("vue").Component) | ((new (...args: any[]) => (string | import("vue").Component) & {}) | (() => string | import("vue").Component))[], unknown, unknown>>;
        readonly required: false;
        readonly validator: ((val: unknown) => boolean) | undefined;
        __epPropKey: true;
    };
}>> & {
    "onCurrent-change"?: ((data: any, node: Node | null) => any) | undefined;
    "onNode-expand"?: ((data: any, node: Node, nodeInstance: ComponentInternalInstance | null) => any) | undefined;
    onCheck?: ((data: any, checkedInfo: import("./tree.type").CheckedInfo) => any) | undefined;
    "onCheck-change"?: ((data: any, checked: boolean, indeterminate: boolean) => any) | undefined;
    "onNode-click"?: ((data: any, node: Node, nodeInstance: ComponentInternalInstance | null, evt: MouseEvent) => any) | undefined;
    "onNode-contextmenu"?: ((evt: Event, data: any, node: Node, nodeInstance: ComponentInternalInstance | null) => any) | undefined;
    "onNode-collapse"?: ((data: any, node: Node, nodeInstance: ComponentInternalInstance | null) => any) | undefined;
    "onNode-drag-start"?: ((node: Node, evt: DragEvent) => any) | undefined;
    "onNode-drag-end"?: ((draggingNode: Node, dropNode: Node | null, dropType: import("./tree.type").NodeDropType, evt: DragEvent) => any) | undefined;
    "onNode-drop"?: ((draggingNode: Node, dropNode: Node, dropType: "after" | "before" | "inner", evt: DragEvent) => any) | undefined;
    "onNode-drag-leave"?: ((draggingNode: Node, oldDropNode: Node, evt: DragEvent) => any) | undefined;
    "onNode-drag-enter"?: ((draggingNode: Node, dropNode: Node, evt: DragEvent) => any) | undefined;
    "onNode-drag-over"?: ((draggingNode: Node, dropNode: Node, evt: DragEvent) => any) | undefined;
}, {
    readonly data: TreeData;
    readonly props: import("./tree.type").TreeOptionProps;
    readonly lazy: boolean;
    readonly draggable: boolean;
    readonly checkStrictly: boolean;
    readonly checkOnClickNode: boolean;
    readonly checkOnClickLeaf: import("element-plus/es/utils").EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly accordion: boolean;
    readonly defaultExpandAll: boolean;
    readonly indent: number;
    readonly autoExpandParent: import("element-plus/es/utils").EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly checkDescendants: boolean;
    readonly renderAfterExpand: import("element-plus/es/utils").EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly expandOnClickNode: import("element-plus/es/utils").EpPropMergeType<BooleanConstructor, unknown, unknown>;
    readonly showCheckbox: boolean;
    readonly highlightCurrent: boolean;
}, {}>;
declare const _default: typeof __VLS_export;
export default _default;
