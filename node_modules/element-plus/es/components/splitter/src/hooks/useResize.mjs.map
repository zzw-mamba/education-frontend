{"version":3,"file":"useResize.mjs","sources":["../../../../../../../packages/components/splitter/src/hooks/useResize.ts"],"sourcesContent":["import { computed, ref, watch } from 'vue'\nimport { getPct, getPx, isPct, isPx } from './useSize'\nimport { NOOP } from '@element-plus/utils'\n\nimport type { ComputedRef, Ref } from 'vue'\nimport type { PanelItemState } from '../type'\n\nexport function useResize(\n  panels: Ref<PanelItemState[]>,\n  containerSize: ComputedRef<number>,\n  pxSizes: ComputedRef<number[]>,\n  lazy: Ref<boolean>\n) {\n  const ptg2px = (ptg: number) => ptg * containerSize.value || 0\n\n  function getLimitSize(\n    str: string | number | undefined,\n    defaultLimit: number\n  ) {\n    if (isPct(str)) {\n      return ptg2px(getPct(str))\n    } else if (isPx(str)) {\n      return getPx(str)\n    }\n    return str ?? defaultLimit\n  }\n\n  const lazyOffset = ref(0)\n  const movingIndex = ref<{\n    index: number\n    confirmed: boolean\n  } | null>(null)\n\n  let cachePxSizes: number[] = []\n  let updatePanelSizes = NOOP\n\n  const limitSizes = computed(() =>\n    panels.value.map((item) => [item.min, item.max])\n  )\n\n  watch(lazy, () => {\n    if (lazyOffset.value) {\n      const mouseup = new MouseEvent('mouseup', { bubbles: true })\n      window.dispatchEvent(mouseup)\n    }\n  })\n\n  const onMoveStart = (index: number) => {\n    lazyOffset.value = 0\n    movingIndex.value = { index, confirmed: false }\n    cachePxSizes = pxSizes.value\n  }\n\n  const onMoving = (index: number, offset: number) => {\n    let confirmedIndex: number | null = null\n\n    // When overlapping, find the nearest draggable index\n    if ((!movingIndex.value || !movingIndex.value.confirmed) && offset !== 0) {\n      if (offset > 0) {\n        confirmedIndex = index\n        movingIndex.value = { index, confirmed: true }\n      } else {\n        for (let i = index; i >= 0; i -= 1) {\n          if (cachePxSizes[i]! > 0) {\n            confirmedIndex = i\n            movingIndex.value = { index: i, confirmed: true }\n            break\n          }\n        }\n      }\n    }\n    const mergedIndex = confirmedIndex ?? movingIndex.value?.index ?? index\n\n    const numSizes = [...cachePxSizes]\n    const nextIndex = mergedIndex + 1\n\n    // Handle the maximum and minimum edge cases\n    const startMinSize = getLimitSize(limitSizes.value[mergedIndex]![0], 0)\n    const endMinSize = getLimitSize(limitSizes.value[nextIndex]![0], 0)\n    const startMaxSize = getLimitSize(\n      limitSizes.value[mergedIndex]![1],\n      containerSize.value || 0\n    )\n    const endMaxSize = getLimitSize(\n      limitSizes.value[nextIndex]![1],\n      containerSize.value || 0\n    )\n\n    let mergedOffset = offset\n\n    if (numSizes[mergedIndex]! + mergedOffset < startMinSize) {\n      mergedOffset = startMinSize - numSizes[mergedIndex]!\n    }\n    if (numSizes[nextIndex]! - mergedOffset < endMinSize) {\n      mergedOffset = numSizes[nextIndex]! - endMinSize\n    }\n    if (numSizes[mergedIndex]! + mergedOffset > startMaxSize) {\n      mergedOffset = startMaxSize - numSizes[mergedIndex]!\n    }\n    if (numSizes[nextIndex]! - mergedOffset > endMaxSize) {\n      mergedOffset = numSizes[nextIndex]! - endMaxSize\n    }\n\n    numSizes[mergedIndex]! += mergedOffset\n    numSizes[nextIndex]! -= mergedOffset\n    lazyOffset.value = mergedOffset\n\n    updatePanelSizes = () => {\n      panels.value.forEach((panel, index) => {\n        panel.size = numSizes[index]\n      })\n      updatePanelSizes = NOOP\n    }\n\n    if (!lazy.value) {\n      updatePanelSizes()\n    }\n  }\n\n  const onMoveEnd = () => {\n    if (lazy.value) {\n      updatePanelSizes()\n    }\n\n    lazyOffset.value = 0\n    movingIndex.value = null\n    cachePxSizes = []\n  }\n\n  const cacheCollapsedSize: number[] = []\n  const onCollapse = (index: number, type: 'start' | 'end') => {\n    if (!cacheCollapsedSize.length) {\n      cacheCollapsedSize.push(...pxSizes.value)\n    }\n\n    const currentSizes = pxSizes.value\n\n    const currentIndex = type === 'start' ? index : index + 1\n    const targetIndex = type === 'start' ? index + 1 : index\n\n    const currentSize = currentSizes[currentIndex]\n    const targetSize = currentSizes[targetIndex]\n\n    if (currentSize !== 0 && targetSize !== 0) {\n      currentSizes[currentIndex] = 0\n      currentSizes[targetIndex]! += currentSize\n      cacheCollapsedSize[index] = currentSize\n    } else {\n      const totalSize = currentSize + targetSize\n\n      const targetCacheCollapsedSize = cacheCollapsedSize[index]\n      const currentCacheCollapsedSize = totalSize - targetCacheCollapsedSize\n\n      currentSizes[targetIndex] = targetCacheCollapsedSize\n      currentSizes[currentIndex] = currentCacheCollapsedSize\n    }\n\n    panels.value.forEach((panel, index) => {\n      panel.size = currentSizes[index]\n    })\n  }\n\n  return {\n    lazyOffset,\n    onMoveStart,\n    onMoving,\n    onMoveEnd,\n    movingIndex,\n    onCollapse,\n  }\n}\n"],"names":["index"],"mappings":"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"}